diff --git a/MITK/Modules/DnDDisplay/niftkMultiWindowWidget.cxx b/MITK/Modules/DnDDisplay/niftkMultiWindowWidget.cxx
index 051eb16..8d5a614 100644
--- a/MITK/Modules/DnDDisplay/niftkMultiWindowWidget.cxx
+++ b/MITK/Modules/DnDDisplay/niftkMultiWindowWidget.cxx
@@ -45,46 +45,6 @@
 namespace niftk
 {
 
-/// The renderer directions give information about how the geometries of the individual renderers
-/// should be created when the viewer is initialised with a 'reference' geometry. The direction
-/// of the first two dimensions (right and bottom vectors) are fixed for each renderer and changing
-/// them would mirror the displayed image. The third dimension (normal vector), however, is
-/// orthogonal to the rendered plane, and can go either ways. Reverting its direction reverts
-/// the order of slice indexes in the slice navigation controller of the renderer.
-///
-/// The renderer directions string has to contain three letters: 'L' or 'R', 'P' or 'A' and 'I' or
-/// 'S'. The letters mean left, right, posterior, anterior, inferior and superior, respectively.
-///
-/// MITK creates the renderer geometries in "RAI" mode, i.e. the index of the rendered slices in
-/// the sagittal window goes from left to right, in the coronal window from back to front and in
-/// the axial window from top to bottom.
-///
-/// It looks more natural to me to create the renderer geometries in "RAS" mode, that is to number
-/// the slices in the axial renderer from bottom to top. This is more consistent with how world
-/// geometries are constructed in MITK. The origin of world geometries is at the bottom-left-back
-/// corner of their bottom-left-back voxel (non-image geometry). Hence, the world indices go from
-/// left to right, back to front and bottom to top, always.
-///
-/// However, using "RAS" directions needs a patch for MITK. See MITK bug T20180 for details.
-///
-/// Note that since the current renderer directions do not follow neither the image directions nor
-/// the world directions, you must *not* rely on the indices in the slice navigation controller of
-/// the renderers, but you always need to translate world coordinates to index coordinates using
-/// the reference geometry that was used to initialise the viewer, and in case of non-image
-/// geometries, you need to subtract 0.5 from the index coordinates before or after the conversion.
-///
-/// In this sense, it rarely matters in which directions the renderer geometries are created.
-/// However, the image navigator connects to the slice navigation controller of the renderers
-/// directly and displays their slice indices in the sliders on the GUI. In case of the sagittal
-/// and coronal renderers the connection is direct but for the axial renderer it is inverted,
-/// to compensate for the flipped direction in the axial renderer window (see T20180).
-///
-/// If we want to see the original image indices in the image navigator, we need to create the
-/// axial renderer geometry in opposite direction as in the image. This 'trick' or work-around
-/// can be removed when T20180 gets fixed.
-
-const std::string MITK_RENDERER_DIRECTIONS = "RAI";
-
 /**
  * This class is to notify the SingleViewerWidget about the display geometry changes of a render window.
  */
@@ -1133,6 +1093,14 @@ void MultiWindowWidget::SetTimeGeometry(const mitk::TimeGeometry* timeGeometry)
       /// This can be an image geometry or a manually created world geometry.
       if (auto slicedGeometry = dynamic_cast<const mitk::SlicedGeometry3D*>(m_ReferenceGeometry))
       {
+        MITK_INFO << "input sliced geometry origin: " << slicedGeometry->GetOrigin();
+        MITK_INFO << "input sliced geometry slice 0 origin: " << slicedGeometry->GetPlaneGeometry(0)->GetOrigin();
+        MITK_INFO << "input sliced geometry slice 0 centre: " << slicedGeometry->GetPlaneGeometry(0)->GetCenter();
+        MITK_INFO << "input sliced geometry slice 1 origin: " << slicedGeometry->GetPlaneGeometry(1)->GetOrigin();
+        MITK_INFO << "input sliced geometry slice 1 centre: " << slicedGeometry->GetPlaneGeometry(1)->GetCenter();
+        MITK_INFO << "input sliced geometry corner point 0: " << slicedGeometry->GetCornerPoint(0);
+        MITK_INFO << "input sliced geometry corner point 7: " << slicedGeometry->GetCornerPoint(7);
+
         if (slicedGeometry->HasReferenceGeometry())
         {
           m_ReferenceGeometry = slicedGeometry->GetReferenceGeometry();
@@ -1300,12 +1268,12 @@ void MultiWindowWidget::SetTimeGeometry(const mitk::TimeGeometry* timeGeometry)
         unsigned int slices = 1;
         mitk::ScalarType viewSpacing = 1;
         bool isFlipped;
-        double distance = 0.5;
 
         // Setting up the width, height, axis orientation.
         switch (viewDirection)
         {
         case mitk::SliceNavigationController::Sagittal:
+          MITK_INFO << "creating sagittal geometry...";
           width  = permutedBoundingBox[1];
           height = permutedBoundingBox[2];
           slices = permutedBoundingBox[0];
@@ -1320,21 +1288,13 @@ void MultiWindowWidget::SetTimeGeometry(const mitk::TimeGeometry* timeGeometry)
           normal[0] = permutedSpacing[0] * permutedMatrix[0][0];
           normal[1] = permutedSpacing[0] * permutedMatrix[1][0];
           normal[2] = permutedSpacing[0] * permutedMatrix[2][0];
-          /// If the direction is not the same as the default direction in MITK, we flip the geometry.
-          if ((m_OrientationString.find('R') != -1) != (MITK_RENDERER_DIRECTIONS.find('R') != -1))
-          {
-            distance = permutedBoundingBox[0] - 0.5;
-            normal[0] *= -1;
-            normal[1] *= -1;
-            normal[2] *= -1;
-            isFlipped = !isFlipped;
-          }
-          originOfSlice[0] += distance * permutedSpacing[0] * permutedMatrix[0][0];
-          originOfSlice[1] += distance * permutedSpacing[0] * permutedMatrix[1][0];
-          originOfSlice[2] += distance * permutedSpacing[0] * permutedMatrix[2][0];
+          originOfSlice[0] += 0.5 * permutedSpacing[0] * permutedMatrix[0][0];
+          originOfSlice[1] += 0.5 * permutedSpacing[0] * permutedMatrix[1][0];
+          originOfSlice[2] += 0.5 * permutedSpacing[0] * permutedMatrix[2][0];
           break;
         /// Coronal:
         case mitk::SliceNavigationController::Frontal:
+          MITK_INFO << "creating coronal geometry...";
           width  = permutedBoundingBox[0];
           height = permutedBoundingBox[2];
           slices = permutedBoundingBox[1];
@@ -1349,53 +1309,39 @@ void MultiWindowWidget::SetTimeGeometry(const mitk::TimeGeometry* timeGeometry)
           normal[0] = permutedSpacing[1] * permutedMatrix[0][1];
           normal[1] = permutedSpacing[1] * permutedMatrix[1][1];
           normal[2] = permutedSpacing[1] * permutedMatrix[2][1];
-          /// If the direction is not the same as the default direction in MITK, we flip the geometry.
-          if ((m_OrientationString.find('A') != -1) != (MITK_RENDERER_DIRECTIONS.find('A') != -1))
-          {
-            distance = permutedBoundingBox[1] - 0.5;
-            normal[0] *= -1;
-            normal[1] *= -1;
-            normal[2] *= -1;
-            isFlipped = !isFlipped;
-          }
-          originOfSlice[0] += distance * permutedSpacing[1] * permutedMatrix[0][1];
-          originOfSlice[1] += distance * permutedSpacing[1] * permutedMatrix[1][1];
-          originOfSlice[2] += distance * permutedSpacing[1] * permutedMatrix[2][1];
+          originOfSlice[0] += 0.5 * permutedSpacing[1] * permutedMatrix[0][1];
+          originOfSlice[1] += 0.5 * permutedSpacing[1] * permutedMatrix[1][1];
+          originOfSlice[2] += 0.5 * permutedSpacing[1] * permutedMatrix[2][1];
           break;
         /// Axial:
         default:
+          MITK_INFO << "creating axial geometry...";
           width  = permutedBoundingBox[0];
           height = permutedBoundingBox[1];
           slices = permutedBoundingBox[2];
           viewSpacing = permutedSpacing[2];
-          isFlipped = true;
+          isFlipped = false;
           rightDV[0] = permutedSpacing[0] * permutedMatrix[0][0];
           rightDV[1] = permutedSpacing[0] * permutedMatrix[1][0];
           rightDV[2] = permutedSpacing[0] * permutedMatrix[2][0];
           bottomDV[0] = -1.0 * permutedSpacing[1] * permutedMatrix[0][1];
           bottomDV[1] = -1.0 * permutedSpacing[1] * permutedMatrix[1][1];
           bottomDV[2] = -1.0 * permutedSpacing[1] * permutedMatrix[2][1];
-          normal[0] = permutedSpacing[2] * permutedMatrix[0][2];
-          normal[1] = permutedSpacing[2] * permutedMatrix[1][2];
-          normal[2] = permutedSpacing[2] * permutedMatrix[2][2];
-          /// If the direction is not the same as the default direction in MITK, we flip the geometry.
-          if ((m_OrientationString.find('S') != -1) != (MITK_RENDERER_DIRECTIONS.find('S') != -1))
-          {
-            distance = permutedBoundingBox[2] - 0.5;
-            normal[0] *= -1;
-            normal[1] *= -1;
-            normal[2] *= -1;
-            isFlipped = !isFlipped;
-          }
+          normal[0] = -1.0 * permutedSpacing[2] * permutedMatrix[0][2];
+          normal[1] = -1.0 * permutedSpacing[2] * permutedMatrix[1][2];
+          normal[2] = -1.0 * permutedSpacing[2] * permutedMatrix[2][2];
           originOfSlice[0] += permutedBoundingBox[1] * permutedSpacing[1] * permutedMatrix[0][1];
           originOfSlice[1] += permutedBoundingBox[1] * permutedSpacing[1] * permutedMatrix[1][1];
           originOfSlice[2] += permutedBoundingBox[1] * permutedSpacing[1] * permutedMatrix[2][1];
-          originOfSlice[0] += distance * permutedSpacing[2] * permutedMatrix[0][2];
-          originOfSlice[1] += distance * permutedSpacing[2] * permutedMatrix[1][2];
-          originOfSlice[2] += distance * permutedSpacing[2] * permutedMatrix[2][2];
+          originOfSlice[0] += (permutedBoundingBox[2] - 0.5) * permutedSpacing[2] * permutedMatrix[0][2];
+          originOfSlice[1] += (permutedBoundingBox[2] - 0.5) * permutedSpacing[2] * permutedMatrix[1][2];
+          originOfSlice[2] += (permutedBoundingBox[2] - 0.5) * permutedSpacing[2] * permutedMatrix[2][2];
           break;
         }
 
+        MITK_INFO << "flipped: " << isFlipped;
+        MITK_INFO << "origin of slice 0: " << originOfSlice;
+
         mitk::TimeStepType numberOfTimeSteps = timeGeometry->CountTimeSteps();
 
         mitk::ProportionalTimeGeometry::Pointer createdTimeGeometry = mitk::ProportionalTimeGeometry::New();
@@ -1440,6 +1386,14 @@ void MultiWindowWidget::SetTimeGeometry(const mitk::TimeGeometry* timeGeometry)
           slicedGeometry->SetImageGeometry(false);
           slicedGeometry->InitializeEvenlySpaced(planeGeometry, viewSpacing, slices, isFlipped);
 
+          MITK_INFO << "sliced geometry origin: " << slicedGeometry->GetOrigin();
+          MITK_INFO << "sliced geometry slice 0 origin: " << slicedGeometry->GetPlaneGeometry(0)->GetOrigin();
+          MITK_INFO << "sliced geometry slice 0 centre: " << slicedGeometry->GetPlaneGeometry(0)->GetCenter();
+          MITK_INFO << "sliced geometry slice 1 origin: " << slicedGeometry->GetPlaneGeometry(1)->GetOrigin();
+          MITK_INFO << "sliced geometry slice 1 centre: " << slicedGeometry->GetPlaneGeometry(1)->GetCenter();
+          MITK_INFO << "sliced geometry corner point 0: " << slicedGeometry->GetCornerPoint(0);
+          MITK_INFO << "sliced geometry corner point 7: " << slicedGeometry->GetCornerPoint(7);
+
           /// TODO The function has been removed in MITK 2014.09.
 //          slicedGeometry->SetTimeBounds(timeGeometry->GetGeometryForTimeStep(timeStep)->GetTimeBounds());
           createdTimeGeometry->SetTimeStepGeometry(slicedGeometry, timeStep);
@@ -1450,23 +1404,21 @@ void MultiWindowWidget::SetTimeGeometry(const mitk::TimeGeometry* timeGeometry)
         sliceNavigationController->Update(mitk::SliceNavigationController::Original, true, true, false);
         sliceNavigationController->SetViewDirection(viewDirection);
 
+        mitk::SlicedGeometry3D* sncGeometry = dynamic_cast<mitk::SlicedGeometry3D*>(sliceNavigationController->GetCreatedWorldGeometry()->GetGeometryForTimeStep(0).GetPointer());
+
+        MITK_INFO << "snc geometry origin: " << sncGeometry->GetOrigin();
+        MITK_INFO << "snc geometry slice 0 origin: " << sncGeometry->GetPlaneGeometry(0)->GetOrigin();
+        MITK_INFO << "snc geometry slice 0 centre: " << sncGeometry->GetPlaneGeometry(0)->GetCenter();
+        MITK_INFO << "snc geometry slice 1 origin: " << sncGeometry->GetPlaneGeometry(1)->GetOrigin();
+        MITK_INFO << "snc geometry slice 1 centre: " << sncGeometry->GetPlaneGeometry(1)->GetCenter();
+        MITK_INFO << "snc geometry corner point 0: " << sncGeometry->GetCornerPoint(0);
+        MITK_INFO << "snc geometry corner point 7: " << sncGeometry->GetCornerPoint(7);
+
         // For 2D mappers only, set to middle slice (the 3D mapper simply follows by event listening).
         if (renderer->GetMapperID() == 1)
         {
           // Now geometry is established, set to middle slice.
           int middleSlicePos = sliceNavigationController->GetSlice()->GetSteps() / 2;
-          if (slices % 2 == 0)
-          {
-            if ((viewDirection == AXIAL
-                 && ((m_OrientationString.find('S') != -1) != (MITK_RENDERER_DIRECTIONS.find('S') != -1)))
-                || (viewDirection == SAGITTAL
-                    && ((m_OrientationString.find('R') != -1) != (MITK_RENDERER_DIRECTIONS.find('R') != -1)))
-                || (viewDirection == CORONAL
-                    && ((m_OrientationString.find('A') != -1) != (MITK_RENDERER_DIRECTIONS.find('A') != -1))))
-            {
-              middleSlicePos -= 1;
-            }
-          }
           sliceNavigationController->GetSlice()->SetPos(middleSlicePos);
         }
 
@@ -2418,29 +2370,7 @@ void MultiWindowWidget::UpdatePositionAnnotation(int windowIndex) const
           selectedPositionInVx[i] -= 0.5;
         }
 
-        std::string orientationString = "---";
-
-        if (windowIndex == 0)
-        {
-          // Axial
-          orientationString[0] = 'R';
-          orientationString[1] = 'P';
-          orientationString[2] = (m_OrientationString.find('S') != -1) == (MITK_RENDERER_DIRECTIONS.find('S') != -1) ? 'S' : 'I';
-        }
-        else if (windowIndex == 1)
-        {
-          // Sagittal
-          orientationString[0] = 'A';
-          orientationString[1] = 'S';
-          orientationString[2] = (m_OrientationString.find('R') != -1) == (MITK_RENDERER_DIRECTIONS.find('R') != -1) ? 'R' : 'L';
-        }
-        else if (windowIndex == 2)
-        {
-          // Coronal
-          orientationString[0] = 'R';
-          orientationString[1] = 'S';
-          orientationString[2] = (m_OrientationString.find('A') != -1) == (MITK_RENDERER_DIRECTIONS.find('A') != -1) ? 'A' : 'P';
-        }
+        std::string orientationString = windowIndex == 0 ? "RPI" : windowIndex == 1 ? "ASR" : "RSA";
 
         stream << selectedPositionInVx[0] << ", " << selectedPositionInVx[1] << ", " << selectedPositionInVx[2] << " vx (" << orientationString << ")" << std::endl;
       }
