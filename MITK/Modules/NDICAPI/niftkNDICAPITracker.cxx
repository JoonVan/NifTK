/*=============================================================================

  NifTK: A software platform for medical image computing.

  Copyright (c) University College London (UCL). All rights reserved.

  This software is distributed WITHOUT ANY WARRANTY; without even
  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.

  See LICENSE.txt in the top level directory for details.

=============================================================================*/

/*=Plus=header=begin======================================================
The Plus license below is a BSD style license, with extensions
to cover contributions and other issues specific to Plus.

For more information, please see:
http://www.plustoolkit.org
______________________________________________________________

How to cite Plus:

Andras Lasso, Tamas Heffter, Adam Rankin, Csaba Pinter, Tamas Ungi, and Gabor Fichtinger, "PLUS: Open-source toolkit for ultrasound-guided intervention systems", IEEE Trans Biomed Eng. 2014 Oct;61(10):2527-37. doi: 10.1109/TBME.2014.2322864

@ARTICLE{Lasso2014a,
  title = {PLUS: Open-source toolkit for ultrasound-guided intervention systems},
  author = {Andras Lasso and Tamas Heffter and Adam Rankin and Csaba Pinter and Tamas Ungi and Gabor Fichtinger},
  journal = {IEEE Transactions on Biomedical Engineering},
  year = {2014},
  month = {Oct},
  number = {10},
  pages = {2527-2537},
  doi = {10.1109/TBME.2014.2322864},
  pmid = {24833412},
  url = {http://perk.cs.queensu.ca/contents/plus-open-source-toolkit-ultrasound-guided-intervention-systems}
}
______________________________________________________________

Plus Contribution and Software License Agreement ("Agreement")
Version 1.0 (October 24, 2011)

This Agreement covers contributions to and downloads from the Plus
project ("Plus") maintained by the Laboratory for Percutaneous
Surgery ("PerkLab"). Part A of this Agreement applies to
contributions of software and/or data to Plus (including making
revisions of or additions to code and/or data already in Plus). Part
B of this Agreement applies to downloads of software and/or data from
Plus. If you distribute Software (as defined below) downloaded from
Plus, all of the paragraphs of Part B of this Agreement must be
included with and apply to such Software.

Your contribution of software and/or data to Plus (including prior
to the date of the first publication of this Agreement, each a
"Contribution") and/or downloading, copying, modifying, displaying,
distributing or use of any software and/or data from Plus
(collectively, the "Software") constitutes acceptance of all of the
terms and conditions of this Agreement. If you do not agree to such
terms and conditions, you have no right to contribute your
Contribution, or to download, copy, modify, display, distribute or use
the Software.

PART A. CONTRIBUTION AGREEMENT - License to PerkLab with Right to
Sublicense ("Contribution Agreement").

1. As used in this Contribution Agreement, "you" means the individual
   contributing the Contribution to Plus and the institution or
   entity which employs or is otherwise affiliated with such
   individual in connection with such Contribution.

2. This Contribution Agreement applies to all Contributions made to
   Plus, including without limitation Contributions made prior to
   the date of first publication of this Agreement. If at any time you
   make a Contribution to Plus, you represent that (i) you are
   legally authorized and entitled to make such Contribution and to
   grant all licenses granted in this Contribution Agreement with
   respect to such Contribution; (ii) if your Contribution includes
   any patient data, all such data is de-identified in accordance with
   U.S. confidentiality and security laws and requirements, including
   but not limited to the Health Insurance Portability and
   Accountability Act (HIPAA) and its regulations, and your disclosure
   of such data for the purposes contemplated by this Agreement is
   properly authorized and in compliance with all applicable laws and
   regulations; and (iii) you have preserved in the Contribution all
   applicable attributions, copyright notices and licenses for any
   third party software or data included in the Contribution.

3. Except for the licenses granted in this Agreement, you reserve all
   right, title and interest in your Contribution.

4. You hereby grant to PerkLab, with the right to sublicense, a
   perpetual, worldwide, non-exclusive, no charge, royalty-free,
   irrevocable license to use, reproduce, make derivative works of,
   display and distribute the Contribution. If your Contribution is
   protected by patent, you hereby grant to PerkLab, with the right to
   sublicense, a perpetual, worldwide, non-exclusive, no-charge,
   royalty-free, irrevocable license under your interest in patent
   rights covering the Contribution, to make, have made, use, sell and
   otherwise transfer your Contribution, alone or in combination with
   any other code.

5. You acknowledge and agree that PerkLab may incorporate your
   Contribution into Plus and may make Plus available to members
   of the public on an open source basis under terms substantially in
   accordance with the Software License set forth in Part B of this
   Agreement. You further acknowledge and agree that PerkLab shall
   have no liability arising in connection with claims resulting from
   your breach of any of the terms of this Agreement.

6. YOU WARRANT THAT TO THE BEST OF YOUR KNOWLEDGE YOUR CONTRIBUTION
   DOES NOT CONTAIN ANY CODE THAT REQURES OR PRESCRIBES AN "OPEN
   SOURCE LICENSE" FOR DERIVATIVE WORKS (by way of non-limiting
   example, the GNU General Public License or other so-called
   "reciprocal" license that requires any derived work to be licensed
   under the GNU General Public License or other "open source
   license").

PART B. DOWNLOADING AGREEMENT - License from PerkLab with Right to
Sublicense ("Software License").

1. As used in this Software License, "you" means the individual
   downloading and/or using, reproducing, modifying, displaying and/or
   distributing the Software and the institution or entity which
   employs or is otherwise affiliated with such individual in
   connection therewith. The Laboratory for Percutanous Surgery
   ("PerkLab") hereby grants you, with right to sublicense, with
   respect to PerkLab's rights in the software, and data, if any,
   which is the subject of this Software License (collectively, the
   "Software"), a royalty-free, non-exclusive license to use,
   reproduce, make derivative works of, display and distribute the
   Software, provided that:

(a) you accept and adhere to all of the terms and conditions of this
Software License;

(b) in connection with any copy of or sublicense of all or any portion
of the Software, all of the terms and conditions in this Software
License shall appear in and shall apply to such copy and such
sublicense, including without limitation all source and executable
forms and on any user documentation, prefaced with the following
words: "All or portions of this licensed product (such portions are
the "Software") have been obtained under license from the Laboratory
for Percutaneous Surgery and are subject to the following terms and
conditions:"

(c) you preserve and maintain all applicable attributions, copyright
notices and licenses included in or applicable to the Software;

(d) modified versions of the Software must be clearly identified and
marked as such, and must not be misrepresented as being the original
Software; and

(e) you consider making, but are under no obligation to make, the
source code of any of your modifications to the Software freely
available to others on an open source basis.

2. The license granted in this Software License includes without
   limitation the right to (i) incorporate the Software into
   proprietary programs (subject to any restrictions applicable to
   such programs), (ii) add your own copyright statement to your
   modifications of the Software, and (iii) provide additional or
   different license terms and conditions in your sublicenses of
   modifications of the Software; provided that in each case your use,
   reproduction or distribution of such modifications otherwise
   complies with the conditions stated in this Software License.

3. This Software License does not grant any rights with respect to
   third party software, except those rights that PerkLab has been
   authorized by a third party to grant to you, and accordingly you
   are solely responsible for (i) obtaining any permissions from third
   parties that you need to use, reproduce, make derivative works of,
   display and distribute the Software, and (ii) informing your
   sublicensees, including without limitation your end-users, of their
   obligations to secure any such required permissions.

4. The Software has been designed for research purposes only and has
   not been reviewed or approved by the Food and Drug Administration
   or by any other agency. YOU ACKNOWLEDGE AND AGREE THAT CLINICAL
   APPLICATIONS ARE NEITHER RECOMMENDED NOR ADVISED. Any
   commercialization of the Software is at the sole risk of the party
   or parties engaged in such commercialization. You further agree to
   use, reproduce, make derivative works of, display and distribute
   the Software in compliance with all applicable governmental laws,
   regulations and orders, including without limitation those relating
   to export and import control.

5. The Software is provided "AS IS" and neither PerkLab nor any
   contributor to the software (each a "Contributor") shall have any
   obligation to provide maintenance, support, updates, enhancements
   or modifications thereto. PERKLAB AND ALL CONTRIBUTORS SPECIFICALLY
   DISCLAIM ALL EXPRESS AND IMPLIED WARRANTIES OF ANY KIND INCLUDING,
   BUT NOT LIMITED TO, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR
   A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
   PERKLAB OR ANY CONTRIBUTOR BE LIABLE TO ANY PARTY FOR DIRECT,
   INDIRECT, SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY ARISING IN ANY WAY
   RELATED TO THE SOFTWARE, EVEN IF PERKLAB OR ANY CONTRIBUTOR HAS
   BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. TO THE MAXIMUM
   EXTENT NOT PROHIBITED BY LAW OR REGULATION, YOU FURTHER ASSUME ALL
   LIABILITY FOR YOUR USE, REPRODUCTION, MAKING OF DERIVATIVE WORKS,
   DISPLAY, LICENSE OR DISTRIBUTION OF THE SOFTWARE AND AGREE TO
   INDEMNIFY AND HOLD HARMLESS PERKLAB AND ALL CONTRIBUTORS FROM AND
   AGAINST ANY AND ALL CLAIMS, SUITS, ACTIONS, DEMANDS AND JUDGMENTS
   ARISING THEREFROM.

6. None of the names, logos or trademarks of PerkLab or any of
   PerkLab's affiliates or any of the Contributors, or any funding
   agency, may be used to endorse or promote products produced in
   whole or in part by operation of the Software or derived from or
   based on the Software without specific prior written permission
   from the applicable party.

7. Any use, reproduction or distribution of the Software which is not
   in accordance with this Software License shall automatically revoke
   all rights granted to you under this Software License and render
   Paragraphs 1 and 2 of this Software License null and void.

8. This Software License does not grant any rights in or to any
   intellectual property owned by PerkLab or any Contributor except
   those rights expressly granted hereunder.
=========================================================Plus=header=end*/

/*=========================================================================
The following copyright notice is applicable to parts of this file:

Copyright (c) 2000-2005 Atamai, Inc.

Use, modification and redistribution of the software, in source or
binary forms, are permitted provided that the following terms and
conditions are met:

1) Redistribution of the source code, in verbatim or modified
   form, must retain the above copyright notice, this license,
   the following disclaimer, and any notices that refer to this
   license and/or the following disclaimer.

2) Redistribution in binary form must include the above copyright
   notice, a copy of this license and the following disclaimer
   in the documentation or with other materials provided with the
   distribution.

3) Modified copies of the source code must be clearly marked as such,
   and must not be misrepresented as verbatim copies of the source code.

THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE "AS IS"
WITHOUT EXPRESSED OR IMPLIED WARRANTY INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  IN NO EVENT SHALL ANY COPYRIGHT HOLDER OR OTHER PARTY WHO MAY
ODIFY AND/OR REDISTRIBUTE THE SOFTWARE UNDER THE TERMS OF THIS LICENSE
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, LOSS OF DATA OR DATA BECOMING INACCURATE
OR LOSS OF PROFIT OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF
THE USE OR INABILITY TO USE THE SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

=========================================================================*/

#include "niftkNDICAPITracker.h"
#include "ndicapi.h"
#include "ndicapi_math.h"

#include <sstream>
#include <iostream>

/* NifTK commented out:
#include "PlusConfigure.h"
#include "vtkCharArray.h"
#include "vtkMath.h"
#include "vtkMatrix4x4.h"
#include "NDICAPITracker.h"
#include "vtkObjectFactory.h"
#include "vtkRecursiveCriticalSection.h"
#include "vtkSocketCommunicator.h"
#include "vtkTimerLog.h"
#include "vtkPlusDataSource.h"
#include "vtkTransform.h"
#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <string.h>
*/

namespace niftk
{

const int VIRTUAL_SROM_SIZE=1024;

//----------------------------------------------------------------------------
NDICAPITracker::NDICAPITracker()
{
  this->Device = 0;
  this->Version = NULL;
  this->IsDeviceTracking = 0;
  this->SerialPort = -1; // default is to probe
  this->BaudRate = 9600;
  this->MeasurementVolumeNumber = 0; // keep default volume

  this->LastFrameNumber=0;

  memset(this->CommandReply,0,VTK_NDI_REPLY_LEN);

  // PortName for data source is not required if RomFile is specified, so we don't need to enable this->RequirePortNameInDeviceSetConfiguration
  
  // No callback function provided by the device, so the data capture thread will be used to poll the hardware and add new items to the buffer
  // NifTK commented out: this->StartThreadForInternalUpdates=true;
  // NifTK commented out: this->AcquisitionRate=50;
}

//----------------------------------------------------------------------------
NDICAPITracker::~NDICAPITracker()
{
  // NifTK commented out: if (this->Recording)
  // NifTK commented out: {
  // NifTK commented out:   this->StopRecording();
  // NifTK commented out: }
  for (NdiToolDescriptorsType::iterator toolDescriptorIt=this->NdiToolDescriptors.begin(); toolDescriptorIt!=this->NdiToolDescriptors.end(); ++toolDescriptorIt)
  {
    delete [] toolDescriptorIt->second.VirtualSROM;
    toolDescriptorIt->second.VirtualSROM = NULL;
  }
  this->SetVersion(NULL);
}

//----------------------------------------------------------------------------
// NifTK commented out: void NDICAPITracker::PrintSelf(ostream& os, vtkIndent indent)
// NifTK commented out: {
// NifTK commented out:   Superclass::PrintSelf(os,indent);
// NifTK commented out: }

//----------------------------------------------------------------------------
std::string NDICAPITracker::GetSdkVersion()
{
  std::ostringstream version; 
  version << "NDICAPI-" << NDICAPI_MAJOR_VERSION << "." << NDICAPI_MINOR_VERSION; 
  return version.str(); 
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::Probe()
{
  if (this->IsDeviceTracking)
  {
    return PLUS_SUCCESS;
  }
  int errnum = NDI_OPEN_ERROR;
  char *devicename = NULL;  
  if (this->SerialPort > 0)
  {
    devicename = ndiDeviceName(this->SerialPort-1);
    if (devicename)
    {
      errnum = ndiProbe(devicename);
    }
  }
  else
  {
    // if SerialPort is set to -1, then probe the first N serial ports
    const int MAX_SERIAL_PORT_NUMBER=20; // the serial port is almost surely less than this number
    for (int i = 0; i < MAX_SERIAL_PORT_NUMBER; i++)
    {
      devicename = ndiDeviceName(i);
      if (devicename)
      {
        errnum = ndiProbe(devicename);
        if (errnum == NDI_OKAY)
        {
          this->SerialPort = i+1;
          break;
        }
      }
    }
  }

  // if probe was okay, then send VER:0 to identify device
  if (errnum != NDI_OKAY)
  {
    return PLUS_FAIL;
  }

  this->Device = ndiOpen(devicename);
  if (this->Device)
  {
    this->SetVersion(ndiVER(this->Device,0));
    ndiClose(this->Device);
    this->Device = 0;
  }
  return PLUS_SUCCESS;
} 

//----------------------------------------------------------------------------
// Send a raw command to the tracking unit.
// If communication has already been opened with the NDI,
// then lock the mutex to get exclusive access and then
// send the command.
// Otherwise, open communication with the unit, send the command,
// and close communication.
char *NDICAPITracker::Command(const char *command)
{
  this->CommandReply[0] = '\0';

  if (this->Device)
  {
    strncpy(this->CommandReply, ndiCommand(this->Device, command), VTK_NDI_REPLY_LEN-1);
    this->CommandReply[VTK_NDI_REPLY_LEN-1] = '\0';
  }
  else
  {
    char *devicename = ndiDeviceName(this->SerialPort-1);
    this->Device = ndiOpen(devicename);
    if (this->Device == 0) 
    {
      std::cerr << ndiErrorString(NDI_OPEN_ERROR) << std::endl;
    }
    else
    {
      strncpy(this->CommandReply, ndiCommand(this->Device, command), VTK_NDI_REPLY_LEN-1);
      this->CommandReply[VTK_NDI_REPLY_LEN-1] = '\0';
      ndiClose(this->Device);
    }
    this->Device = 0;
  }

  return this->CommandReply;
}


//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::InternalConnect()
{ 
  int baud = NDI_9600;
  switch (this->BaudRate)
  {
  case 9600: baud = NDI_9600; break; 
  case 14400: baud = NDI_14400; break; 
  case 19200: baud = NDI_19200; break; 
  case 38400: baud = NDI_38400; break; 
  case 57600: baud = NDI_57600; break; 
  case 115200: baud = NDI_115200; break;
  case 921600: baud = NDI_921600; break;
  case 1228739: baud = NDI_1228739; break;
  default:
    std::cerr << "Illegal baud rate: " << this->BaudRate << ". Valid values: 9600, 14400, 19200, 38400, 5760, 115200, 921600, 1228739" << std::endl;
    return PLUS_FAIL;
  }

  char *devicename = ndiDeviceName(this->SerialPort-1);
  this->Device = ndiOpen(devicename);
  if (this->Device == 0) 
  {
    std::cerr << "Failed to open port: " << (devicename == NULL ? "unknown" : devicename) << " - " << ndiErrorString(NDI_OPEN_ERROR) << std::endl;
    return PLUS_FAIL;
  }
  // initialize Device
  bool resetOccurred=false;
  const char* initCommandReply=ndiCommand(this->Device,"INIT:");
  if (initCommandReply!=NULL && strncmp(initCommandReply,"RESET",5)==0)
  {
    // The tracker device was left in high-speed mode after exiting debugger. When the INIT was sent at 9600 baud,
    // the device reset back to default 9600 and returned status RESET.
    // Re-issue the INIT command to avoid 'command not valid in current mode' errors.
    resetOccurred=true;
  }
  int errnum = 0;
  if (ndiGetError(this->Device) || resetOccurred)
  {
    ndiRESET(this->Device);
    //ndiGetError(this->Device); // ignore the error
    ndiCommand(this->Device,"INIT:");
    errnum = ndiGetError(this->Device);
    if (errnum) 
    {
      std::cerr << ndiErrorString(errnum) << std::endl;
      ndiClose(this->Device);
      this->Device = 0;
      return PLUS_FAIL;
    }
  }

  // set the baud rate
  // also: NOHANDSHAKE cuts down on CRC errs and timeouts
  ndiCommand(this->Device,"COMM:%d%03d%d",baud,NDI_8N1,NDI_NOHANDSHAKE);
  errnum = ndiGetError(this->Device);
  if (errnum) 
  {
    std::cerr << ndiErrorString(errnum) << std::endl;
    ndiClose(this->Device);
    this->Device = 0;
    return PLUS_FAIL;
  }

  if (this->MeasurementVolumeNumber!=0)
  {
    const char* volumeSelectCommandReply=ndiCommand(this->Device,"VSEL:%d",this->MeasurementVolumeNumber);
    errnum = ndiGetError(this->Device);
    if (errnum) 
    {
      std::cerr << "Failed to set measurement volume "<< this->MeasurementVolumeNumber << ": " << ndiErrorString(errnum) << std::endl;

      const unsigned char MODE_GET_VOLUMES_LIST = 0x03; // list of volumes available
      const char* volumeListCommandReply=ndiCommand(this->Device,"SFLIST:%02X",MODE_GET_VOLUMES_LIST);
      errnum = ndiGetError(this->Device);
      if (errnum || volumeListCommandReply==NULL)
      {
        std::cerr << "Failed to retrieve list of available volumes: " << ndiErrorString(errnum) << std::endl;
      }
      else
      {
        LogVolumeList(volumeListCommandReply, 0);
      }
      ndiClose(this->Device);
      this->Device = 0;
      return PLUS_FAIL;
    }
    else
    {
      const unsigned char MODE_GET_VOLUMES_LIST = 0x03; // list of volumes available
      const char* volumeListCommandReply=ndiCommand(this->Device,"SFLIST:%02X",MODE_GET_VOLUMES_LIST);
      errnum = ndiGetError(this->Device);
      if (!errnum || volumeListCommandReply!=NULL)
      {
        LogVolumeList(volumeListCommandReply, this->MeasurementVolumeNumber);
      }
    }
  }

  // get information about the device
  this->SetVersion(ndiVER(this->Device,0));

  if (this->EnableToolPorts()!=PLUS_SUCCESS)
  {
    std::cerr << "Failed to enable tool ports" << std::endl;
    return PLUS_FAIL;
  }

  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::InternalDisconnect()
{ 
  for (NdiToolDescriptorsType::iterator toolDescriptorIt=this->NdiToolDescriptors.begin(); toolDescriptorIt!=this->NdiToolDescriptors.end(); ++toolDescriptorIt)
  {
    this->ClearVirtualSromInTracker(toolDescriptorIt->second);
  }

  this->DisableToolPorts();

  // return to default comm settings
  ndiCommand(this->Device,"COMM:00000");
  int errnum = ndiGetError(this->Device);
  if (errnum) 
  {
    std::cerr << ndiErrorString(errnum) << std::endl;
  }
  ndiClose(this->Device);
  this->Device = 0;

  return PLUS_SUCCESS;
}


//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::InternalStartRecording()
{
  if (this->IsDeviceTracking)
  {
    return PLUS_SUCCESS;
  }

  ndiCommand(this->Device,"TSTART:");
  int errnum = ndiGetError(this->Device);
  if (errnum) 
  {
    std::cerr << "Failed TSTART: " << ndiErrorString(errnum) << std::endl;
    ndiClose(this->Device);
    this->Device = 0;
    return PLUS_FAIL;
  }

  this->IsDeviceTracking = 1;

  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::InternalStopRecording()
{
  if (this->Device == 0)
  {
    return PLUS_FAIL;
  }

  ndiCommand(this->Device,"TSTOP:");
  int errnum = ndiGetError(this->Device);
  if (errnum) 
  {
    std::cerr << ndiErrorString(errnum) << std::endl;
  }
  this->IsDeviceTracking = 0;

  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::InternalUpdate()
{  
  m_TrackerMatrices.clear();

  if (!this->IsDeviceTracking)
  {
    std::cerr << "called Update() when NDI was not tracking" << std::endl;
    return PLUS_FAIL;
  }

  int errnum=0;

  // get the transforms for all tools from the NDI
  ndiCommand(this->Device,"TX:0801");
  errnum = ndiGetError(this->Device);
  if (errnum)
  {
    if (errnum == NDI_BAD_CRC || errnum == NDI_TIMEOUT) // common errors
    {
      std::cerr << ndiErrorString(errnum) << std::endl;
    }
    else
    {
      std::cerr << ndiErrorString(errnum) << std::endl;
    }
    return PLUS_FAIL;
  }

  // default to incrementing frame count by one (in case a frame index cannot be retrieved from the tracker for a specific tool)
  this->LastFrameNumber++;
  int defaultToolFrameNumber = this->LastFrameNumber;

  // Try to extract matrix for each tool we are tracking.
  NdiToolDescriptorsType::iterator ndiToolDescriptorIt;
  for (ndiToolDescriptorIt = NdiToolDescriptors.begin();
       ndiToolDescriptorIt != NdiToolDescriptors.end();
       ++ndiToolDescriptorIt)
  {
    int portHandle = ndiToolDescriptorIt->second.PortHandle;
    if (portHandle <= 0)
    {
      std::cerr << "Port handle is invalid for tool " << ndiToolDescriptorIt->first << std::endl;
      continue;
    }

    double ndiTransform[8]={1,0,0,0,0,0,0,0};
    int ndiToolAbsent = ndiGetTXTransform(this->Device, portHandle, ndiTransform);
    int ndiPortStatus = ndiGetTXPortStatus(this->Device, portHandle);
    unsigned long ndiFrameIndex = ndiGetTXFrame(this->Device, portHandle);

    const unsigned long ndiPortStatusValidFlags = NDI_TOOL_IN_PORT | NDI_INITIALIZED | NDI_ENABLED;
    if ((ndiPortStatus & ndiPortStatusValidFlags) == ndiPortStatusValidFlags) 
    {
      double transformMatrix[16] = {1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1};
      ndiTransformToMatrixd(ndiTransform,transformMatrix);

      std::vector<double> transformMatrixAsSTLVector(16);
      for (int i = 0; i < 16; i++)
      {
        transformMatrixAsSTLVector[i] = transformMatrix[i];
      }
      m_TrackerMatrices.insert(std::pair<std::string, std::vector<double> >(ndiToolDescriptorIt->first, transformMatrixAsSTLVector));
    }
  }

/* NifTK commented out, as this is PLUS specific.
  const double toolTimestamp = vtkAccurateTimer::GetSystemTime(); // unfiltered timestamp
  vtkSmartPointer<vtkMatrix4x4> toolToTrackerTransform=vtkSmartPointer<vtkMatrix4x4>::New();
  for (DataSourceContainerConstIterator it = this->GetToolIteratorBegin(); it != this->GetToolIteratorEnd(); ++it)
  {
    ToolStatus toolFlags = TOOL_OK;
    toolToTrackerTransform->Identity();
    unsigned long toolFrameNumber = defaultToolFrameNumber;
    vtkPlusDataSource* trackerTool = it->second;
    std::string toolSourceId=trackerTool->GetSourceId();
    NdiToolDescriptorsType::iterator ndiToolDescriptorIt = this->NdiToolDescriptors.find(toolSourceId);
    if (ndiToolDescriptorIt==this->NdiToolDescriptors.end())
    {
      LOG_ERROR("Tool descriptor is not found for tool "<<toolSourceId);
      this->ToolTimeStampedUpdate(trackerTool->GetSourceId(), toolToTrackerTransform, toolFlags, toolFrameNumber, toolTimestamp);
      continue;
    }
    int portHandle = ndiToolDescriptorIt->second.PortHandle;
    if (portHandle <= 0)
    {
      LOG_ERROR("Port handle is invalid for tool "<<toolSourceId);
      this->ToolTimeStampedUpdate(toolSourceId.c_str(), toolToTrackerTransform, toolFlags, toolFrameNumber, toolTimestamp);
      continue;
    }

    double ndiTransform[8]={1,0,0,0,0,0,0,0};
    int ndiToolAbsent = ndiGetTXTransform(this->Device, portHandle, ndiTransform);
    int ndiPortStatus = ndiGetTXPortStatus(this->Device, portHandle);
    unsigned long ndiFrameIndex = ndiGetTXFrame(this->Device, portHandle);

    // convert status flags from NDI to Plus format
    const unsigned long ndiPortStatusValidFlags = NDI_TOOL_IN_PORT | NDI_INITIALIZED | NDI_ENABLED;
    if ((ndiPortStatus & ndiPortStatusValidFlags) != ndiPortStatusValidFlags) 
    {
      toolFlags = TOOL_MISSING;
    }
    else
    {
      if (ndiToolAbsent)
      {
        toolFlags = TOOL_OUT_OF_VIEW;
      }
      if (ndiPortStatus & NDI_OUT_OF_VOLUME)
      {
        toolFlags = TOOL_OUT_OF_VOLUME;
      }
      // TODO all these button state toolFlags are on regardless of the actual state
      //if (ndiPortStatus & NDI_SWITCH_1_ON)  { toolFlags = TOOL_SWITCH1_IS_ON; }
      //if (ndiPortStatus & NDI_SWITCH_2_ON)  { toolFlags = TOOL_SWITCH2_IS_ON; }
      //if (ndiPortStatus & NDI_SWITCH_3_ON)  { toolFlags = TOOL_SWITCH3_IS_ON; }
    }

    ndiTransformToMatrixd(ndiTransform,*toolToTrackerTransform->Element);
    toolToTrackerTransform->Transpose();

    // by default (if there is no camera frame number associated with
    // the tool transformation) the most recent timestamp is used.    
    if (!ndiToolAbsent && ndiFrameIndex)
    {
      // this will create a timestamp from the frame number      
      toolFrameNumber = ndiFrameIndex;
      if (ndiFrameIndex>this->LastFrameNumber)
      {
        this->LastFrameNumber=ndiFrameIndex;
      }
    }

    // send the matrix and status to the tool's vtkPlusDataBuffer
    this->ToolTimeStampedUpdate(toolSourceId.c_str(), toolToTrackerTransform, toolFlags, toolFrameNumber, toolTimestamp);
  }
*/

  // Update tool connections if a wired tool is plugged in
  if (ndiGetTXSystemStatus(this->Device) & NDI_PORT_OCCUPIED)
  { 
    std::cerr << "A wired tool has been plugged into tracker " << std::endl; // NifTK commented out: (this->GetDeviceId()?this->GetDeviceId():"(unknown NDI tracker"));
    // Make the newly connected tools available
    this->EnableToolPorts();
  }

  return PLUS_SUCCESS;
}


//----------------------------------------------------------------------------
std::map<std::string, std::vector<double> > NDICAPITracker::GetTrackerMatrices()
{
  return m_TrackerMatrices;
}


//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::ReadSromFromFile(NdiToolDescriptor& toolDescriptor, const char *filename)
{
  FILE *file = fopen(filename,"rb");
  if (file == NULL)
  {
    std::cerr << "couldn't find srom file " << filename << std::endl;
    return PLUS_FAIL;
  }

  if (toolDescriptor.VirtualSROM == 0)
  {
    toolDescriptor.VirtualSROM = new unsigned char[VIRTUAL_SROM_SIZE];
  }

  memset(toolDescriptor.VirtualSROM,0,VIRTUAL_SROM_SIZE);
  fread(toolDescriptor.VirtualSROM,1,VIRTUAL_SROM_SIZE,file);
  fclose(file);
  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::EnableToolPorts()
{
  NDICAPITracker::PlusStatus status=PLUS_SUCCESS;

  // stop tracking
  if (this->IsDeviceTracking)
  {
    ndiCommand(this->Device,"TSTOP:");
    int errnum = ndiGetError(this->Device);
    if (errnum)
    { 
      std::cerr << ndiErrorString(errnum) << std::endl;
      status=PLUS_FAIL;
    }    
  }

  // free ports that are waiting to be freed
  {
    ndiCommand(this->Device,"PHSR:01");
    int ntools = ndiGetPHSRNumberOfHandles(this->Device);
    for (int ndiToolIndex = 0; ndiToolIndex < ntools; ndiToolIndex++)
    {
      int portHandle = ndiGetPHSRHandle(this->Device,ndiToolIndex);
      ndiCommand(this->Device,"PHF:%02X",portHandle);
      int errnum = ndiGetError(this->Device);
      if (errnum)
      { 
        std::cerr << ndiErrorString(errnum) << std::endl;
        status=PLUS_FAIL;
      }
    }
  }

  // Set port handles and send SROM files to tracker
  // We need to do this before initializing and enabling
  // the ports waiting to be initialized.
  for (NdiToolDescriptorsType::iterator toolDescriptorIt=this->NdiToolDescriptors.begin(); toolDescriptorIt!=this->NdiToolDescriptors.end(); ++toolDescriptorIt)
  {
    if (toolDescriptorIt->second.VirtualSROM != NULL) // wireless tool (or wired tool with virtual rom)
	{  
      if (this->UpdatePortHandle(toolDescriptorIt->second)!=PLUS_SUCCESS)
      {
        std::cerr << "Failed to determine NDI port handle for tool " << toolDescriptorIt->first << std::endl;
        return PLUS_FAIL;
      }
      if (this->SendSromToTracker(toolDescriptorIt->second)!=PLUS_SUCCESS)
      {
        std::cerr << "Failed send SROM to NDI tool " << toolDescriptorIt->first << std::endl;
        return PLUS_FAIL;
      }
    }
  }

  // initialize ports waiting to be initialized
  {
    int errnum=0;
    int ntools=0;
    do // repeat as necessary (in case multi-channel tools are used) 
    {
      ndiCommand(this->Device,"PHSR:02");
      ntools = ndiGetPHSRNumberOfHandles(this->Device);
      for (int ndiToolIndex = 0; ndiToolIndex < ntools; ndiToolIndex++)
      {
        int portHandle = ndiGetPHSRHandle(this->Device,ndiToolIndex);
        ndiCommand(this->Device,"PINIT:%02X",portHandle);
        errnum = ndiGetError(this->Device);
        if (errnum)
        { 
          std::cerr << ndiErrorString(errnum) << std::endl;
          status=PLUS_FAIL;
        }
      }
    }
    while (ntools > 0 && errnum == 0);
  }

  // enable initialized tools
  {
    ndiCommand(this->Device,"PHSR:03");
    int ntools = ndiGetPHSRNumberOfHandles(this->Device);
    for (int ndiToolIndex = 0; ndiToolIndex < ntools; ndiToolIndex++)
    {
      int portHandle = ndiGetPHSRHandle(this->Device,ndiToolIndex);
      ndiCommand(this->Device,"PHINF:%02X0001",portHandle);
      char identity[34];
      ndiGetPHINFToolInfo(this->Device,identity);
      int mode='D'; // default
      if (identity[1] == 0x03) // button-box
      {
        mode = 'B';
      }
      else if (identity[1] == 0x01) // reference
      {
        mode = 'S';
      }
      // enable the tool
      ndiCommand(this->Device,"PENA:%02X%c",portHandle,mode);
      int errnum = ndiGetError(this->Device);
      if (errnum)
      {
        std::cerr << ndiErrorString(errnum) << std::endl;
        status=PLUS_FAIL;
      }
    }
  }

  // Set wired port handles and send SROM files to tracker
  // We need to do this after enabling all the tools because tools on
  // splitters (two 5-DOF tools with one connector) only appear after the tool is enabled.
  for (NdiToolDescriptorsType::iterator toolDescriptorIt=this->NdiToolDescriptors.begin(); toolDescriptorIt!=this->NdiToolDescriptors.end(); ++toolDescriptorIt)
  {
	  if (toolDescriptorIt->second.WiredPortNumber >= 0 && toolDescriptorIt->second.VirtualSROM == 0) //wired tool, no virtual rom
    {
      if (this->UpdatePortHandle(toolDescriptorIt->second)!=PLUS_SUCCESS)
      {
        std::cerr << "Failed to determine NDI port handle for tool "<<toolDescriptorIt->first << std::endl;
        return PLUS_FAIL;
      }
      if (this->SendSromToTracker(toolDescriptorIt->second)!=PLUS_SUCCESS)
      {
        std::cerr << "Failed send SROM to NDI tool "<<toolDescriptorIt->first << std::endl;
        return PLUS_FAIL;
      }
    }
  }

  // Update tool info

  ndiCommand(this->Device,"PHSR:00");

  for (NdiToolDescriptorsType::iterator toolDescriptorIt=this->NdiToolDescriptors.begin(); toolDescriptorIt!=this->NdiToolDescriptors.end(); ++toolDescriptorIt)
  {
    // NifTK commented out: vtkPlusDataSource* trackerTool = NULL;
    // NifTK commented out: if ( this->GetTool(toolDescriptorIt->first, trackerTool) != PLUS_SUCCESS )
    // NifTK commented out: {
    // NifTK commented out:   std::cerr << "Failed to get NDI tool: " << toolDescriptorIt->first << std::endl;
    // NifTK commented out:   status=PLUS_FAIL;
    // NifTK commented out:   continue; 
    // NifTK commented out: }

    ndiCommand(this->Device,"PHINF:%02X0025",toolDescriptorIt->second.PortHandle);
    int errnum = ndiGetError(this->Device);
    if (errnum)
    { 
      std::cerr << ndiErrorString(errnum) << std::endl;
      status=PLUS_FAIL;
      continue;
    }

    // decompose identity string from end to front
    char identity[34];
    ndiGetPHINFToolInfo(this->Device, identity);
    identity[31] = '\0';
    std::string serialNumber(&identity[23]);
    // NifTK commented out:PlusCommon::Trim(serialNumber);
    // NifTK commented out:trackerTool->SetCustomProperty("SerialNumber", serialNumber);
    identity[23] = '\0';
    std::string toolRevision(&identity[20]);
    // NifTK commented out:PlusCommon::Trim(toolRevision);
    // NifTK commented out:trackerTool->SetCustomProperty("Revision", toolRevision);
    identity[20] = '\0';
    std::string toolManufacturer(&identity[8]);
    // NifTK commented out:PlusCommon::Trim(toolManufacturer);
    // NifTK commented out:trackerTool->SetCustomProperty("Manufacturer", toolManufacturer);
    identity[8] = '\0';
    // NifTK commented out:trackerTool->SetCustomProperty("NdiIdentity",PlusCommon::Trim(&identity[0]));
    char partNumber[24];
    ndiGetPHINFPartNumber(this->Device, partNumber);
    partNumber[20] = '\0';
    std::string toolPartNumber(&partNumber[0]);
    // NifTK commented out:PlusCommon::Trim(toolPartNumber);
    // NifTK commented out:trackerTool->SetCustomProperty("PartNumber", toolPartNumber);
    int status = ndiGetPHINFPortStatus(this->Device);

    {
      std::cout << "Initialising:" << std::endl;
      std::cout << "  SerialNumber:" << serialNumber << std::endl;
      std::cout << "  Revision    :" << toolRevision << std::endl;
      std::cout << "  Manufacturer:" << toolManufacturer << std::endl;
      std::cout << "  NdiIdentity :" << identity << std::endl;
      std::cout << "  PartNumber  :" << partNumber << std::endl;
    }

    toolDescriptorIt->second.PortEnabled = ((status & NDI_ENABLED) != 0);
    if (!toolDescriptorIt->second.PortEnabled)
    {
      std::cerr << "Failed to enable NDI tool " << toolDescriptorIt->first << std::endl;
      status=PLUS_FAIL;
    }
  }

  // re-start the tracking
  if (this->IsDeviceTracking)
  {
    ndiCommand(this->Device,"TSTART:");
    int errnum = ndiGetError(this->Device);
    if (errnum)
    { 
      std::cerr << "Failed TSTART: " << ndiErrorString(errnum) << std::endl;
      status=PLUS_FAIL;
    }
  }
  
  return status;
}

//----------------------------------------------------------------------------
// Disable all enabled tool ports.
void NDICAPITracker::DisableToolPorts()
{
  // stop tracking
  if (this->IsDeviceTracking)
  {
    ndiCommand(this->Device,"TSTOP:");
    int errnum = ndiGetError(this->Device);
    if (errnum)
    { 
      std::cerr << ndiErrorString(errnum) << std::endl;
    }    
  }

  // disable all enabled tools
  ndiCommand(this->Device,"PHSR:04");
  int ntools = ndiGetPHSRNumberOfHandles(this->Device);
  for (int ndiToolIndex = 0; ndiToolIndex < ntools; ndiToolIndex++)
  {
    int portHandle = ndiGetPHSRHandle(this->Device,ndiToolIndex);
    ndiCommand(this->Device,"PDIS:%02X",portHandle);
    int errnum = ndiGetError(this->Device);
    if (errnum)
    { 
      std::cerr << ndiErrorString(errnum) << std::endl;
    }    
  }

  // disable the enabled ports
  for (NdiToolDescriptorsType::iterator toolDescriptorIt=this->NdiToolDescriptors.begin(); toolDescriptorIt!=this->NdiToolDescriptors.end(); ++toolDescriptorIt)
  {
    toolDescriptorIt->second.PortEnabled = false;
  }

  // re-start the tracking
  if (this->IsDeviceTracking)
  {
    ndiCommand(this->Device,"TSTART:");
    int errnum = ndiGetError(this->Device);
    if (errnum)
    { 
      std::cerr << ndiErrorString(errnum) << std::endl;
    }
  }
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::Beep(int n)
{
  // NifTK commented out: if (this->Recording)
  // NifTK commented out: {
  // NifTK commented out:   std::cerr << "NDICAPITracker::Beep failed: not connected to the device" << std::endl;
  // NifTK commented out:   return PLUS_FAIL;
  // NifTK commented out: }
  if (n > 9)
  {
    n = 9;
  }
  if (n < 0)
  {
    n = 0;
  }
  ndiCommand(this->Device,"BEEP:%i",n);
  int errnum = ndiGetError(this->Device);
  /*
  if (errnum && errnum != NDI_NO_TOOL)
  {
    LOG_ERROR(ndiErrorString(errnum));
    return PLUS_FAIL;
  }
  */
  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus  NDICAPITracker::SetToolLED(const char* sourceId, int led, LedState state)
{
  // NifTK commented out: if (!this->Recording)
  // NifTK commented out: {
  // NifTK commented out:   std::cerr << "NDICAPITracker::InternalSetToolLED failed: not recording" << std::endl;
  // NifTK commented out:   return PLUS_FAIL;
  // NifTK commented out: }
  NdiToolDescriptorsType::iterator ndiToolDescriptorIt = this->NdiToolDescriptors.find(sourceId);
  if (ndiToolDescriptorIt==this->NdiToolDescriptors.end())
  {
    std::cerr << "InternalSetToolLED failed: Tool descriptor is not found for tool " << sourceId << std::endl;
    return PLUS_FAIL;
  }
  int portHandle=ndiToolDescriptorIt->second.PortHandle;
  if (portHandle <= 0)
  {
    std::cerr << "NDICAPITracker::InternalSetToolLED failed: invalid port handle" << std::endl;
    return PLUS_FAIL;
  }

  int plstate = NDI_BLANK;
  switch (state)
  {
  case TR_LED_OFF: plstate = NDI_BLANK; break;
  case TR_LED_ON: plstate = NDI_SOLID; break;
  case TR_LED_FLASH: plstate = NDI_FLASH; break;
  default:
    std::cerr << "NDICAPITracker::InternalSetToolLED failed: unsupported LED state: "<<state << std::endl;
    return PLUS_FAIL;
  }

  ndiCommand(this->Device, "LED:%02X%d%c", portHandle, led+1, plstate);
  int errnum = ndiGetError(this->Device);
  /*
  if (errnum && errnum != NDI_NO_TOOL)
  {
  LOG_ERROR(ndiErrorString(errnum));
  return 0;
  }
  */

  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::UpdatePortHandle(NdiToolDescriptor& toolDescriptor)
{  
  if (toolDescriptor.WiredPortNumber>=0) // wired tool
  {
    ndiCommand(this->Device, "PHSR:00");
    int ntools = ndiGetPHSRNumberOfHandles(this->Device);
    int ndiToolIndex = 0;
    for (; ndiToolIndex < ntools; ndiToolIndex++)
    {
      if (ndiGetPHSRInformation(this->Device,ndiToolIndex) & NDI_TOOL_IN_PORT)
      {
        int portHandle = ndiGetPHSRHandle(this->Device,ndiToolIndex);
        ndiCommand(this->Device,"PHINF:%02X0021",portHandle);
        char location[14];
        ndiGetPHINFPortLocation(this->Device,location);
        int foundWiredPortNumber = (location[10]-'0')*10 + (location[11]-'0') - 1;
        int foundWiredPortChannel = (location[12]-'0')*10 + (location[13]-'0'); // this is nonzero if 5-DOF tools with splitter
        int combinedPortAndChannelNumber = foundWiredPortChannel*100 + foundWiredPortNumber;
        if (toolDescriptor.WiredPortNumber == combinedPortAndChannelNumber)
        {
          // found the portHandle
          toolDescriptor.PortHandle = portHandle;
          break;
        }
      }
    }
    if (ndiToolIndex == ntools)
    {
      std::cerr << "Active NDI tool not found in port " << toolDescriptor.WiredPortNumber <<". Make sure the tool is plugged in." << std::endl;
      return PLUS_FAIL;
    }    
  }
  else // wireless tool
  {
    ndiCommand(this->Device, "PHRQ:*********1****");
    int portHandle = ndiGetPHRQHandle(this->Device);
    toolDescriptor.PortHandle = portHandle;
  }

  int errnum = ndiGetError(this->Device);
  if (errnum)
  {
    std::cerr << ndiErrorString(errnum) << std::endl;
    return PLUS_FAIL;
  }
  
  return PLUS_SUCCESS;
}


//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::SendSromToTracker(const NdiToolDescriptor& toolDescriptor)
{
  if (toolDescriptor.VirtualSROM == NULL)
  {
    // nothing to load
    return PLUS_SUCCESS;
  }

  const int TRANSFER_BLOCK_SIZE=64; // in bytes
  char hexbuffer[TRANSFER_BLOCK_SIZE*2];
  for (int i = 0; i < VIRTUAL_SROM_SIZE; i += TRANSFER_BLOCK_SIZE)
  {
    ndiCommand(this->Device," VER 0");
    ndiCommand(this->Device, "PVWR:%02X%04X%.128s", toolDescriptor.PortHandle, i,
      ndiHexEncode(hexbuffer, &(toolDescriptor.VirtualSROM[i]), TRANSFER_BLOCK_SIZE));
  }

  int errnum = ndiGetError(this->Device);
  if (errnum) 
  {
    std::cerr << "Failed to send SROM to NDI tracker" << std::endl;
    std::cerr << ndiErrorString(errnum) << std::endl;
    return PLUS_FAIL;
  }

  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
NDICAPITracker::PlusStatus NDICAPITracker::ClearVirtualSromInTracker(NdiToolDescriptor& toolDescriptor)
{
  if (toolDescriptor.VirtualSROM==NULL)
  {
    // nothing to clear
    return PLUS_SUCCESS;
  }

  ndiCommand(this->Device, "PHF:%02X", toolDescriptor.PortHandle);
  toolDescriptor.PortEnabled = false;
  toolDescriptor.PortHandle = 0;

  return PLUS_SUCCESS;
}

//----------------------------------------------------------------------------
// NifTK commented out: PlusStatus NDICAPITracker::ReadConfiguration(vtkXMLDataElement* rootConfigElement)
// NifTK commented out: {
// NifTK commented out:   // Clean up any previously read config data
// NifTK commented out:   for (NdiToolDescriptorsType::iterator toolDescriptorIt=this->NdiToolDescriptors.begin(); toolDescriptorIt!=this->NdiToolDescriptors.end(); ++toolDescriptorIt)
// NifTK commented out:   {
// NifTK commented out:     delete [] toolDescriptorIt->second.VirtualSROM;
// NifTK commented out:     toolDescriptorIt->second.VirtualSROM = NULL;
// NifTK commented out:   }
// NifTK commented out:   this->NdiToolDescriptors.clear();
// NifTK commented out:
// NifTK commented out:   XML_FIND_DEVICE_ELEMENT_REQUIRED_FOR_READING(deviceConfig, rootConfigElement);
// NifTK commented out:
// NifTK commented out:   XML_READ_SCALAR_ATTRIBUTE_OPTIONAL(unsigned long, SerialPort, deviceConfig);
// NifTK commented out:   XML_READ_SCALAR_ATTRIBUTE_OPTIONAL(unsigned long, BaudRate, deviceConfig);
// NifTK commented out:   XML_READ_SCALAR_ATTRIBUTE_OPTIONAL(int, MeasurementVolumeNumber, deviceConfig);
// NifTK commented out:
// NifTK commented out:   XML_FIND_NESTED_ELEMENT_REQUIRED(dataSourcesElement, deviceConfig, "DataSources");
// NifTK commented out:
// NifTK commented out:   for ( int nestedElementIndex = 0; nestedElementIndex < dataSourcesElement->GetNumberOfNestedElements(); nestedElementIndex++ )
// NifTK commented out:   {
// NifTK commented out:     vtkXMLDataElement* toolDataElement = dataSourcesElement->GetNestedElement(nestedElementIndex);
// NifTK commented out:     if ( STRCASECMP(toolDataElement->GetName(), "DataSource") != 0 )
// NifTK commented out:     {
// NifTK commented out:       // if this is not a data source element, skip it
// NifTK commented out:       continue;
// NifTK commented out:     }
// NifTK commented out:     if ( toolDataElement->GetAttribute("Type") != NULL && STRCASECMP(toolDataElement->GetAttribute("Type"), "Tool") != 0 )
// NifTK commented out:     {
// NifTK commented out:       // if this is not a Tool element, skip it
// NifTK commented out:       continue;
// NifTK commented out:     }
// NifTK commented out:     const char* toolId = toolDataElement->GetAttribute("Id");
// NifTK commented out:     if ( toolId==NULL)
// NifTK commented out:     {
// NifTK commented out:       LOG_ERROR("Failed to initialize NDI tool: DataSource Id is missing");
// NifTK commented out:       continue;
// NifTK commented out:     }
// NifTK commented out:     PlusTransformName toolTransformName(toolId, this->GetToolReferenceFrameName());
// NifTK commented out:     std::string toolSourceId=toolTransformName.GetTransformName();
// NifTK commented out:     vtkPlusDataSource* trackerTool = NULL;
// NifTK commented out:     if ( this->GetTool(toolSourceId, trackerTool) != PLUS_SUCCESS || trackerTool==NULL)
// NifTK commented out:     {
// NifTK commented out:       LOG_ERROR("Failed to get NDI tool: " << toolSourceId);
// NifTK commented out:       continue;
// NifTK commented out:     }
// NifTK commented out:
// NifTK commented out:     int wiredPortNumber = -1;
// NifTK commented out:     if ( toolDataElement->GetAttribute("PortName") != NULL )
// NifTK commented out:     {
// NifTK commented out:       if (!toolDataElement->GetScalarAttribute("PortName", wiredPortNumber))
// NifTK commented out:       {
// NifTK commented out:         LOG_WARNING("NDI wired tool's PortName attribute has to be an integer >=0");
// NifTK commented out:         continue;
// NifTK commented out:       }
// NifTK commented out:     }
// NifTK commented out:
// NifTK commented out:     NdiToolDescriptor toolDescriptor;
// NifTK commented out:     toolDescriptor.PortEnabled=false;
// NifTK commented out:     toolDescriptor.PortHandle=0;
// NifTK commented out:     toolDescriptor.VirtualSROM=NULL;
// NifTK commented out:     toolDescriptor.WiredPortNumber=wiredPortNumber;
// NifTK commented out:
// NifTK commented out:     const char* romFileName = toolDataElement->GetAttribute("RomFile");
// NifTK commented out:     if (romFileName)
// NifTK commented out:     {
// NifTK commented out:       // Passive (wireless) tool or wired tool with virtual rom
// NifTK commented out:       if (wiredPortNumber>=0)
// NifTK commented out:       {
// NifTK commented out:         LOG_WARNING("NDI PortName and RomFile are both specified for tool "<<toolSourceId<<". Assuming broken wired rom, using virtual rom instead");
// NifTK commented out:       }
// NifTK commented out:       std::string romFilePath = vtkPlusConfig::GetInstance()->GetDeviceSetConfigurationPath(romFileName);
// NifTK commented out:       this->ReadSromFromFile(toolDescriptor, romFilePath.c_str());
// NifTK commented out:     }
// NifTK commented out:
// NifTK commented out:     this->NdiToolDescriptors[toolSourceId]=toolDescriptor;
// NifTK commented out:   }
// NifTK commented out:
// NifTK commented out:   return PLUS_SUCCESS;
// NifTK commented out: }

//----------------------------------------------------------------------------
// NifTK commented out: PlusStatus NDICAPITracker::WriteConfiguration(vtkXMLDataElement* rootConfig)
// NifTK commented out: {
// NifTK commented out:   XML_FIND_DEVICE_ELEMENT_REQUIRED_FOR_WRITING(trackerConfig, rootConfig);
// NifTK commented out:   trackerConfig->SetIntAttribute("SerialPort", this->SerialPort);
// NifTK commented out:   trackerConfig->SetIntAttribute("BaudRate", this->BaudRate );
// NifTK commented out:   trackerConfig->SetIntAttribute("MeasurementVolumeNumber", this->MeasurementVolumeNumber );
// NifTK commented out:   return PLUS_SUCCESS;
// NifTK commented out: }

//----------------------------------------------------------------------------
void NDICAPITracker::LogVolumeList(const char* ndiVolumeListCommandReply, int selectedVolume)
{
  unsigned long numberOfVolumes = ndiHexToUnsignedLong(ndiVolumeListCommandReply, 1);
  if (selectedVolume==0)
  {
    std::cout << "Number of available measurement volumes: " << numberOfVolumes << std::endl;
  }
  for (int volIndex=0; volIndex<numberOfVolumes; volIndex++)
  {
    if (selectedVolume>0 && selectedVolume!=volIndex+1)
    {
      continue;
    }
    std::cout << "Measurement volume " << volIndex+1 << std::endl;
    const char* volDescriptor = ndiVolumeListCommandReply+1+volIndex*74;

    std::string shapeType;
    switch (volDescriptor[0])
    {
    case '9': shapeType="Cube volume"; break;
    case 'A': shapeType="Dome volume"; break;
    default: shapeType="unknown";
    }
    std::cout << " Shape type: " << shapeType << " (" << volDescriptor[0] << ")" << std::endl;

    std::cout << " D1 (minimum x value) = " << ndiSignedToLong(volDescriptor+1, 7)/100 << std::endl;
    std::cout << " D2 (maximum x value) = " << ndiSignedToLong(volDescriptor+8, 7)/100 << std::endl;
    std::cout << " D3 (minimum y value) = " << ndiSignedToLong(volDescriptor+15, 7)/100 << std::endl;
    std::cout << " D4 (maximum y value) = " << ndiSignedToLong(volDescriptor+22, 7)/100 << std::endl;
    std::cout << " D5 (minimum z value) = " << ndiSignedToLong(volDescriptor+29, 7)/100 << std::endl;
    std::cout << " D6 (maximum z value) = " << ndiSignedToLong(volDescriptor+36, 7)/100 << std::endl;
    std::cout << " D7 (reserved) = "<<ndiSignedToLong(volDescriptor+43, 7)/100 << std::endl;
    std::cout << " D8 (reserved) = "<<ndiSignedToLong(volDescriptor+50, 7)/100 << std::endl;
    std::cout << " D9 (reserved) = "<<ndiSignedToLong(volDescriptor+57, 7)/100 << std::endl;
    std::cout << " D10 (reserved) = "<<ndiSignedToLong(volDescriptor+64, 7)/100 << std::endl;

    std::cout << " Reserved: "<<volDescriptor[71] << std::endl;

    std::string metalResistant;
    switch (volDescriptor[72])
    {
    case '0': metalResistant="no information"; break;
    case '1': metalResistant="metal resistant"; break;
    case '2': metalResistant="not metal resistant"; break;
    default: metalResistant="unknown";
    }
    std::cout << " Metal resistant: " << metalResistant << " (" << volDescriptor[72] << ")" << std::endl;
  }
}

} // end namespace
