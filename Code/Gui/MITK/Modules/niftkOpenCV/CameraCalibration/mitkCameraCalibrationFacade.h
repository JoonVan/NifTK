/*=============================================================================

  NifTK: A software platform for medical image computing.

  Copyright (c) University College London (UCL). All rights reserved.

  This software is distributed WITHOUT ANY WARRANTY; without even
  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.

  See LICENSE.txt in the top level directory for details.

=============================================================================*/

#ifndef MITKCAMERACALIBRATIONFACADE_H
#define MITKCAMERACALIBRATIONFACADE_H

#include <cv.h>
#include <cstdlib>
#include <iostream>

/**
 * \file mitkCameraCalibrationFacade
 * \brief Interface to OpenCV camera calibration.
 */
namespace mitk {

/**
 * \brief Uses OpenCV to load chessboard images from a directory.
 * \throw Throws logic_error if fullDirectoryName is not a valid directory,
 * the directory contains no files, or there are no files that are images that OpenCV recognises.
 * \param images output parameter containing the images, which the caller must de-allocate.
 * \param fileNames output vector containing the corresponding filenames.
 */
 void LoadChessBoardsFromDirectory(const std::string& fullDirectoryName,
                                   std::vector<IplImage*>& images,
                                   std::vector<std::string>& fileNames);


/**
 * \brief Iterates through the list of images, checking that the width and height are consistent.
 * \throw Throws logic_error if any images are of different size to the first, or the list is empty.
 * \param width output parameter containing the image width for all the images.
 * \param height output parameter containing the image height for all the images.
 */
void CheckConstImageSize(const std::vector<IplImage*>& images, int& width, int& height);


/**
 * \brief Extracts the chess board points, using OpenCV routines.
 * \param images vector of pointers to images, all of the same size.
 * \param fileNames the corresponding file names, and this vector must be the same length as the vector of images.
 * \param numberCornersWidth the number of internal corners along the width axis (X).
 * \param numberCornersHeight the number of internal corners along the height axis (Y).
 * \param drawCorners if true will dump images in the same directory as the input images, to indicate which points were found.
 * \param outputImages list of successfully processed images, which are just pointers back to the same images as in the first parameter vector, i.e. they are not copied, so don't de-allocate them twice.
 * \param outputFileNames corresponding list of successfully processed image filenames,
 * \param outputImagePoints output image points, array size = number of successes*numberOfCorners x 3, and caller must de-allocate.
 * \param outputObjectPoints output object points, array size = number of successes*numberOfCorners x 2, and caller must de-allocate.
 * \param outputPointCounts output point counts, array size = number of successes x 1, and caller must de-allocate.
 */
void ExtractChessBoardPoints(const std::vector<IplImage*>& images,
                             const std::vector<std::string>& fileNames,
                             const int& numberCornersWidth,
                             const int& numberCornersHeight,
                             const bool& drawCorners,
                             std::vector<IplImage*>& outputImages,
                             std::vector<std::string>& outputFileNames,
                             CvMat*& outputImagePoints,
                             CvMat*& outputObjectPoints,
                             CvMat*& outputPointCounts
                             );


/**
 * \brief Calibrate a single camera's intrinsic parameters, by directly calling cvCalibrationCamera2.
 * \param objectPoints list of 3D points generated by ExtractChessBoardPoints.
 * \param imagePoints list of 2D image points generated by ExtractChessBoardPoints.
 * \param pointCounts array containing the number of points that matched, where each entry in this array should be the same.
 * \param outputIntrinsicMatrix 3 x 3 matrix.
 * \param outputDistortionCoefficients 5 x 1 matrix of (k1, k2, p1, p2, k3).
 * \param flags A bit-wise OR, of zero, CV_CALIB_USE_INTRINSIC_GUESS, CV_CALIB_FIX_PRINCIPAL_POINT, CV_CALIB_FIX_ASPECT_RATIO,
 * CV_CALIB_FIX_FOCAL_LENGTH, CV_CALIB_FIXK1, CV_CALIB_FIXK2, CV_CALIB_FIXK3 and CV_CALIB_ZERO_TANGENT_DIST.
 */
double CalibrateSingleCameraIntrinsicParameters(
       const CvMat& objectPoints,
       const CvMat& imagePoints,
       const CvMat& pointCounts,
       const CvSize& imageSize,
       CvMat& outputIntrinsicMatrix,
       CvMat& outputDistortionCoefficients,
       const int& flags=0
       );


/**
 * \brief Calibrate a single camera's intrinsic parameters by using 3 passes, firstly with fixed principal point
 * and fixed aspect ratio, then with fixed principal point, then with nothing fixes.
 * \param objectPoints list of 3D points generated by ExtractChessBoardPoints.
 * \param imagePoints list of 2D image points generated by ExtractChessBoardPoints.
 * \param pointCounts array containing the number of points that matched, where each entry in this array should be the same.
 * \param outputIntrinsicMatrix 3 x 3 matrix.
 * \param outputDistortionCoefficients 5 x 1 matrix of (k1, k2, p1, p2, k3).
 */
double CalibrateSingleCameraIntrinsicUsing3Passes(
       const CvMat& objectPoints,
       const CvMat& imagePoints,
       const CvMat& pointCounts,
       const CvSize& imageSize,
       CvMat& outputIntrinsicMatrix,
       CvMat& outputDistortionCoefficients
       );


/**
 * \brief Calibrate a single cameras extrinsic parameters.
 * \param objectPoints list of 3D points for 1 image view of a chess board.
 * \param imagePoints list of 2D image points for 1 image view of a chess board.
 * \param intrinsicMatrix 3 x 3 matrix of pre-initialised intrinsic parameters.
 * \param distortionCoefficients 5 x 1 matrix of (k1, k2, p1, p2, k3), pre-initialised.
 * \param outputRotationMatrix the rotation matrix - see OpenCV docs - for this function its a 3x3 not a 1x3.
 * \param outputTranslationVector the 1 x 3 translation vector.
 */
void CalibrateSingleCameraExtrinsicParameters(
     const CvMat& objectPoints,
     const CvMat& imagePoints,
     const CvMat& intrinsicMatrix,
     const CvMat& distortionCoefficients,
     CvMat& outputRotationMatrix,
     CvMat& outputTranslationVector
     );


/**
 * \brief Calibrate a single camera for both intrinsic and extrinsic parameters.
 * \param numberSuccessfulViews the number of successful views from ExtractChessBoardPoints.
 * \param objectPoints list of 3D points generated as output from ExtractChessBoardPoints for all M views, M x 3 matrix.
 * \param imagePoints list of 2D image points generated as output from ExtractChessBoardPoints for all M views, M x 2 matrix.
 * \param pointCounts array containing the number of points that matched, which should all be equal for all M views, M x 1 matrix.
 * \param outputIntrinsicMatrix 3 x 3 matrix.
 * \param outputDistortionCoefficients 5 x 1 matrix of (k1, k2, p1, p2, k3).
 * \param outputRotationMatrix an M x 3 matrix of rotation vectors, see also cvRodrigues2 to convert from a rotation vector to a rotation matrix.
 * \param outputTranslationVector an M x 3 matrix of translation vectors.
 */
double CalibrateSingleCameraParameters(
     const int& numberSuccessfulViews,
     const CvMat& objectPoints,
     const CvMat& imagePoints,
     const CvMat& pointCounts,
     const CvSize& imageSize,
     CvMat& outputIntrinsicMatrix,
     CvMat& outputDistortionCoefficients,
     CvMat& outputRotationVectors,
     CvMat& outputTranslationVectors
     );


/**
 * \brief The above method CalibrateSingleCameraParameters outputs a whole load of rotation and translation vectors,
 * so this utility method reconstructs a single extrinsic parameter matrix.
 * \param rotationVectors M x 3 matrix of rotation vectors, where M is the number of views of the chess board.
 * \param translationVectors M x 3 matrix of translation vectors, where M is the number of views of the chess board.
 * \param viewNumber which view to extract, where 0 <= viewNumber < M, and viewNumber is unvalidated (unchecked).
 * \param outputExtrinsicMatrix the output matrix, which should be a pre-allocated 4x4 matrix
 */
void ExtractExtrinsicMatrixFromRotationAndTranslationVectors(
    const CvMat& rotationVectors,
    const CvMat& translationVectors,
    const int& viewNumber,
    CvMat& outputExtrinsicMatrix
    );


/**
 * \brief Bulk method to project all points for all calibrations back to 2D, useful for validating calibration.
 * \param numberSuccessfulViews the number of successful views from ExtractChessBoardPoints.
 * \param pointCount the number of detected points in each view
 * \param objectPoints list of 3D points generated as output from ExtractChessBoardPoints for all M views, M x 3 matrix.
 * \param imagePoints list of 2D image points generated as output from ExtractChessBoardPoints for all M views, M x 2 matrix.
 * \param intrinsicMatrix 3 x 3 matrix of pre-initialised intrinsic parameters.
 * \param distortionCoefficients 5 x 1 matrix of (k1, k2, p1, p2, k3), pre-initialised.
 * \param rotationVectors an M x 3 matrix of rotation vectors, see also cvRodrigues2 to convert from a rotation vector to a rotation matrix.
 * \param translationVectors an M x 3 matrix of translation vectors.
 * \param outputImagePoints list of 2D image points generated by calling cvProjectPoints2.
 */
void ProjectAllPoints(
    const int& numberSuccessfulViews,
    const int& pointCount,
    const CvMat& objectPoints,
    const CvMat& imagePoints,
    const CvMat& intrinsicMatrix,
    const CvMat& distortionCoeffictions,
    const CvMat& rotationVectors,
    const CvMat& translationVectors,
    CvMat& outputImagePoints
    );


/**
 * \brief Performs a stereo calibration, including all intrinsic, extrinsic, distortion co-efficients,
 * and also outputs the rotation and translation vector between the two cameras.
 */
double CalibrateStereoCameraParameters(
    const int& numberSuccessfulViews,
    const CvMat& objectPointsLeft,
    const CvMat& imagePointsLeft,
    const CvMat& pointCountsLeft,
    const CvSize& imageSize,
    const CvMat& objectPointsRight,
    const CvMat& imagePointsRight,
    const CvMat& pointCountsRight,
    CvMat& outputIntrinsicMatrixLeft,
    CvMat& outputDistortionCoefficientsLeft,
    CvMat& outputRotationVectorsLeft,
    CvMat& outputTranslationVectorsLeft,
    CvMat& outputIntrinsicMatrixRight,
    CvMat& outputDistortionCoefficientsRight,
    CvMat& outputRotationVectorsRight,
    CvMat& outputTranslationVectorsRight,
    CvMat& outputRightToLeftRotation,
    CvMat& outputRightToLeftTranslation,
    CvMat& outputEssentialMatrix,
    CvMat& outputFundamentalMatrix
    );

/**
 * \brief Utility method to dump output to a stream.
 */
void OutputCalibrationData(
    std::ostream& outputStream,
    const CvMat& objectPoints,
    const CvMat& imagePoints,
    const CvMat& pointCounts,
    const CvMat& intrinsicMatrix,
    const CvMat& distortionCoefficients,
    const CvMat& rotationVectors,
    const CvMat& translationVectors,
    const float& projectionError,
    const int& sizeX,
    const int& sizeY,
    const int& cornersX,
    const int& cornersY,
    std::vector<std::string>& fileNames
    );


/**
 * \brief Loads an image and parameters and writes the distortion corrected image
 * to the output. Assumes that both the intrinsic camera params and distortion coefficients
 * are in OpenCV's xml format.
 */
void CorrectDistortionInImageFile(
    const std::string& inputImageFileName,
    const std::string& inputIntrinsicsFileName,
    const std::string& inputDistortionCoefficientsFileName,
    const std::string& outputImageFileName
    );

/**
 * \brief Method that reads a single image (eg. png, jpg or anything that OpenCV recognises)
 * and corrects it using the intrinsic params and distortion co-efficients, and writes
 * it to the output file.
 */
void CorrectDistortionInImageFile(
    const std::string& inputFileName,
    const CvMat& intrinsicParams,
    const CvMat& distortionCoefficients,
    const std::string& outputFileName
    );


/**
 * \brief Assuming image is pre-allocated, will take the intrinsic and distortion parameters
 * and calculate a pixel-wise undistortion map, and apply it to image.
 */
void CorrectDistortionInSingleImage(
    const CvMat& intrinsicParams,
    const CvMat& distortionCoefficients,
    IplImage &image
    );


/**
 * \brief Assumes all image buffers are pre-allocated and the same size,
 * and applies mapX and mapY to image.
 */
void UndistortImageUsingDistortionMap(
    const IplImage &mapX,
    const IplImage &mapY,
    IplImage &image
    );


/**
 * \brief Assumes all image buffers are pre-allocated and the same size,
 * and applies mapX and mapY to the inputImage, and writes to outputImage.
 */
void ApplyDistortionCorrectionMap(
    const IplImage &mapX,
    const IplImage &mapY,
    const IplImage &inputImage,
    IplImage &outputImage
    );


/**
 * \brief Used to project 3D points into 2D locations for a stereo pair.
 */
void ProjectLeftCamera3DPositionToStereo2D(
    const CvMat& modelPointsIn3D,
    const CvMat& leftCameraIntrinsic,
    const CvMat& leftCameraDistortion,
    const CvMat& leftCameraRotationVector,
    const CvMat& leftCameraTranslationVector,
    const CvMat& rightCameraIntrinsic,
    const CvMat& rightCameraDistortion,
    const CvMat& rightToLeftRotationMatrix,
    const CvMat& rightToLeftTranslationVector,
    CvMat& output2DPointsLeft,
    CvMat& output2DPointsRight
    );

} // end namespace

#endif // MITKCAMERACALIBRATIONFACADE_H
